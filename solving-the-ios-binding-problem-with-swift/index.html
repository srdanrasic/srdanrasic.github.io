<!DOCTYPE html>
<html lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Solving the iOS Binding Problem with Swift &middot; Srdan Rasic
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body class="theme-base-08 layout-reverse">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p></p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Blog</a>

    

    
    
      
        
      
    
      
        
      
    
      
        
          <a class="sidebar-nav-item" href="/about.html">About</a>
        
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://www.github.com/srdanrasic">GitHub</a>
    <a class="sidebar-nav-item" href="https://www.twitter.com/srdanrasic">Twitter</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Srdan Rasic</a>
            <small>A software engineer</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Solving the iOS Binding Problem with Swift</h1>
  <span class="post-date">19 Feb 2015</span>
  <p><em>This text was originally published at <a href="http://five.agency/solving-the-binding-problem-with-swift/">http://five.agency/solving-the-binding-problem-with-swift/</a>. Check out the original for some nice illustrations! </em></p>

<p>In a fight for great software architecture, our hands are often tied by the shortcomings of frameworks or languages we work with. Simple tasks like downloading a photo and presenting it in a view, updating a view when underlying data changes, or propagating user input to a model tend to introduce unnecessary complexity to our code.</p>

<p>Problem is that we’re so used to thinking in terms of value assignments that we try to apply same approach to situations that require something different. Assignment is a one-time operation. It’s low-level. It’s good for static values. Assignment is, however, terrible for dynamic data. In order to accommodate prices that change, followers that rise or faces that get prettier we need something of a higher level. We need to think in terms of bindings.</p>

<p>In this post we’ll present a solution that makes binding of dynamic data to user interfaces as simple as it gets, giving you an opportunity to focus on what needs to be done, rather than on how to do it.</p>
<h2>Problem analysis</h2>
<p>Let’s explore a simple example of dynamic data. Say that we’re developing some kind of a discussion thread feature. We’ll consider a one-thread scenario. Thread will have a name and a list of posts. Each post will be composed of a body and number of likes. In the real world, models would have more properties like user reference or a date, but we’ll ignore those as they are not important for our problem analysis.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Thread</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">posts</span><span class="p">:</span> <span class="p">[</span><span class="kt">Post</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Post</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">String</span>
  <span class="k">var</span> <span class="nv">likeCount</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We need a view that will display the thread. Let’s define a view with a name label and a posts table view composed of a post cells.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ThreadView</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">nameLabel</span><span class="p">:</span> <span class="kt">UILabel</span>
  <span class="k">var</span> <span class="nv">postsTableView</span><span class="p">:</span> <span class="kt">UITableView</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">PostCell</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">bodyTextView</span><span class="p">:</span> <span class="kt">UITextView</span>
  <span class="k">var</span> <span class="nv">likeCountLabel</span><span class="p">:</span> <span class="kt">UILabel</span>
<span class="p">}</span>
</code></pre>
</div>

<p>What’s left is coupling all that together. Say we’re doing it from a view controller.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ThreadViewController</span><span class="p">:</span> <span class="kt">UIViewController</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">thread</span><span class="p">:</span> <span class="kt">Thread</span>
  <span class="k">var</span> <span class="nv">threadView</span><span class="p">:</span> <span class="kt">ThreadView</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    <span class="n">threadView</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">text</span>
    <span class="n">threadView</span><span class="o">.</span><span class="n">postsTableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">thread</span><span class="o">.</span><span class="nf">count</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="s">"PostCell"</span><span class="p">)</span> <span class="k">as</span> <span class="kt">PostCell</span>
    <span class="k">let</span> <span class="nv">post</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">posts</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>

    <span class="n">cell</span><span class="o">.</span><span class="n">bodyTextView</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">post</span><span class="o">.</span><span class="n">body</span>
    <span class="n">cell</span><span class="o">.</span><span class="n">likeCountLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"</span><span class="se">\(</span><span class="n">post</span><span class="o">.</span><span class="n">likeCount</span><span class="se">)</span><span class="s">"</span>

    <span class="k">return</span> <span class="n">cell</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Simple enough. Sure, but there is problem. Users can write posts. Thread name might be updated. Some of the currently visible posts might even get liked. What will happen to our view? Exactly - nothing. Data from the model is assigned once. Any subsequent change to it will not be reflected in the view. Your likes won’t count. We don’t want that to happen, do we?</p>
<h2>OK, but what are our options?</h2>
<p>There are a couple of ways to fix that. The simplest and probably dumbest solution would be to <strong>expose methods on the view controller that update its state</strong>, then give the model the reference to the view controller and have it call exposed methods whenever change occurs. Oh, and also to say goodbye to any future reusability of those components, to simple object graphs, to single responsibility principle and other “unimportant” principles.</p>

<p>A better solution would be to have the model <strong>define a protocol that parties interested in observing its changes would implement</strong>. In that case, thread view controller would implement the protocol and register itself to the model as an observer (a delegate). This approach makes components more reusable but it’s cumbersome to implement, especially if you have many models. When you think about it, it’s actually same as the first approach, just wrapped up in nice colors.</p>

<p>Another solution might be to <strong>use Key-Value-Observing mechanism to observe data changes and update the view accordingly</strong>. While this approach keeps architecture simple, it’s quite hard to use and, due to its nature, unsafe in some situations. You need to be vigilant while adding and removing observers. You also need to manually downcast objects, as KVO is not type-safe. Additionally, you can’t do “fine grain” observing of an array, so you’d have to reload whole table regardless of the kind of array update.</p>

<p>Of course, you could do something totally different. For example, you could <strong>introduce a Functional reactive paradigm to your architecture with ReactiveCocoa framework and use streams and signals to solve the issue</strong>. While it’s a good solution, it introduces a whole new paradigm as well as the complexity you might not need.</p>

<p>What we would like is something as simple as static assignment, but without the burden of additional protocols, complexities or limitations.</p>
<h2>A Swift solution</h2>
<p>In order to keep the view up to date with the underlying data, we must somehow observe changes in the data and propagate them to the view. There is no way to have some third party observe the changes of a variable, but if you give it some thought, same thing can be achieved by wrapping a variable in an object and updating its value through that object. Now we have a way to intercept changes and notify interested parties of what happened.</p>

<p>In order to do that, we’ll use a neat Swift feature called <em>property observers</em>. Additionally, we’ll use <em>generics</em> to make our wrapper compatible with any type. Let’s call it Dynamic, as it encapsulates dynamic data.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span> <span class="p">{</span>
    <span class="k">didSet</span> <span class="p">{</span>
      <span class="c1">// Inform interested parties</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">v</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>That should be straightforward - a class that encapsulates a value of generic type T. Setting of a value is intercepted by <em>didSet</em> property observer. What’s left if to inform interested parties that change occurred, but before we can do that, we need to define what those parties actually are. Time for another round of thinking.</p>

<p>What’s on the other end of our problem? A view. All kinds of views. Sometimes even something other than a view, maybe another model or an action. It makes sense to think of that side of the problem as a task that needs to be done - view updated, model changed or an action performed. Tasks can be defined by a closure, and that’s how we’ll define our task. We’ll call that task closure Listener and define it as follows:
<code class="highlighter-rouge">swifttypealias Listener = T -&gt; Void</code>
In other words, Listener is a closure that accepts a value of generic type T and performs some task with received value. It doesn’t return anything.</p>

<p>Next, we need to somehow couple our Dynamic and our Listener, so that a Listener gets called whenever a value of a Dynamic changes. We could have a property on the Dynamic that retains a Listener, but that would not be a good idea because we don’t want tasks to be owned by the data. We want tasks to be alive when they are needed (for example while the view is alive) and we want them out of our way when we don’t need them. For that reason, we’ll wrap them in an object.</p>

<p>We are aiming for a type that can encapsulate a Listener closure and that can be bound to the Dynamic so that data changes can trigger closure calls. Let’s call it Bond as it creates a bond between a Dynamic and a Listener. Here is the definition:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">listener</span><span class="p">:</span> <span class="kt">Listener</span>

  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">listener</span><span class="p">:</span> <span class="kt">Listener</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">listener</span> <span class="o">=</span> <span class="n">listener</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">bind</span><span class="p">(</span><span class="nv">dynamic</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Bind to given dynamic</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Nothing too hard. To wrap things up, let’s implement actual binding support. For that, we’ll need to extend the Dynamic with an array of Bonds and implement <em>didSet</em> property observer so it iterates over that array and calls wrapped closures.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span> <span class="p">{</span>
    <span class="k">didSet</span> <span class="p">{</span>
      <span class="k">for</span> <span class="n">bondBox</span> <span class="k">in</span> <span class="n">bonds</span> <span class="p">{</span>
        <span class="n">bondBox</span><span class="o">.</span><span class="n">bond</span><span class="p">?</span><span class="o">.</span><span class="nf">listener</span><span class="p">?(</span><span class="n">value</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">var</span> <span class="nv">bonds</span><span class="p">:</span> <span class="p">[</span><span class="kt">BondBox</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">v</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">v</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">BondBox</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">weak</span> <span class="k">var</span> <span class="nv">bond</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">?</span>
  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="n">bond</span> <span class="o">=</span> <span class="n">b</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Notice how we’ve wrapped array elements in a helper class named BondBox. That’s because we don’t want to strongly reference bonded Bonds. Their life cycle is their own business.</p>

<p>Actual binding is done by appending Bonds to <em>bonds</em> array. We’ll do that in <em>bind</em> method of class Bond.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">listener</span><span class="p">:</span> <span class="kt">Listener</span>

  <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">listener</span><span class="p">:</span> <span class="kt">Listener</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">listener</span> <span class="o">=</span> <span class="n">listener</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">bind</span><span class="p">(</span><span class="nv">dynamic</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">dynamic</span><span class="o">.</span><span class="n">bonds</span><span class="o">.</span><span class="nf">append</span><span class="p">(</span><span class="kt">BondBox</span><span class="p">(</span><span class="k">self</span><span class="p">))</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>That’s it - we have our binding mechanism. We can use our thread name property as an example. For start, we’ll make it dynamic String instead of just String, like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">var</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
</code></pre>
</div>

<p>Setting of a value is done through value property:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">name</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="s">"Steve"</span>
</code></pre>
</div>

<p>How do we bind it to <em>nameLabel</em>? First we create a Bond with a closure that updates the label.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">nameBond</span> <span class="o">=</span> <span class="kt">Bond</span><span class="p">()</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="k">self</span><span class="p">]</span> <span class="n">name</span> <span class="k">in</span>
  <span class="k">self</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">name</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Then we bind it:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">nameBond</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre>
</div>

<p>Mission accomplished. Whenever a value of name property changes, the text of <em>nameLabel</em> will also change to newly set name.</p>

<h2>Brushing it up</h2>
<p>Although presented solution solves the problem of complex architecture and is type-safe, it’s still inconvenient to use and potentially unsafe. We have to create Bonds, retain them, write closures and worry about strongly referencing self.</p>

<p>If we think a bit more about it, it becomes obvious that the views themselves should provide Bonds to which we could attach Dynamics. For example, task of updating the label doesn’t change, it’s always: “update the text property to new value”. Doing that manually is bad, but fortunately, Swift allows us to extend existing types with new functionality.</p>

<p>Let’s explore how that would work on a label. We’ll extend it, so it provides another property - a Bond object:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">private</span> <span class="k">var</span> <span class="nv">handle</span><span class="p">:</span> <span class="kt">UInt8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kd">extension</span> <span class="kt">UILabel</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">textBond</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nv">b</span><span class="p">:</span> <span class="kt">AnyObject</span> <span class="o">=</span> <span class="nf">objc_getAssociatedObject</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">b</span> <span class="k">as</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">b</span> <span class="o">=</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="k">self</span><span class="p">]</span> <span class="n">v</span> <span class="k">in</span> <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">v</span> <span class="p">}</span>
      <span class="nf">objc_setAssociatedObject</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="nf">objc_AssociationPolicy</span><span class="p">(</span><span class="kt">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="p">))</span>
      <span class="k">return</span> <span class="n">b</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Looks somewhat ugly, but it’s actually very simple. As UIKit is an Objective-C framework, we can use <em>associated objects</em> mechanism to associate arbitrary object to a UILabel. In this case, we’re associating a Bond object with a closure that updates label’s text property. We can do similar thing for other types of views like image views, text views, buttons, sliders, etc.</p>

<p>Let’s see how that simplifies our bindings. Instead of creating and retaining a Bond object, writing a closure and dealing with self, we can do this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">nameLabel</span><span class="o">.</span><span class="n">textBond</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</code></pre>
</div>

<p>Much easier and safer, but there is still room left for an improvement. We could define a custom operator that replaces that bind method.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">infix</span> <span class="k">operator</span> <span class="o">-&gt;&gt;</span> <span class="p">{</span> <span class="k">as</span><span class="n">sociativity</span> <span class="k">left</span> <span class="k">precedence</span> <span class="mi">105</span> <span class="p">}</span>

<span class="kd">public</span> <span class="kd">func</span> <span class="o">-&gt;&gt;</span> <span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">right</span><span class="o">.</span><span class="nf">bind</span><span class="p">(</span><span class="k">left</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
</div>

<p>With that, we can bind our data to view like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">name</span> <span class="o">-&gt;&gt;</span> <span class="n">nameLabel</span><span class="o">.</span><span class="n">textBond</span>
</code></pre>
</div>

<p>It can get even better. Let’s define a common protocol for types that can be “bonded to” like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">Bondable</span> <span class="p">{</span>
  <span class="kd">typealias</span> <span class="kt">BondType</span>
  <span class="k">var</span> <span class="nv">designatedBond</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">BondType</span><span class="o">&gt;</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It defines the <em>designatedBond</em> property. In case of UILabel, the designated bond would be <em>textBond, </em>in case of an image view it might be <em>imageBond</em>. For example:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">extension</span> <span class="kt">UILabel</span><span class="p">:</span> <span class="kt">Bondable</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">designatedBond</span><span class="p">:</span> <span class="kt">Bond</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">self</span><span class="o">.</span><span class="n">textBond</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Reason we want it defined through protocol is that we want to perform certain actions on objects that adhere to it without caring of what concrete type object really is, which could be UILabel, UIImageView, UISlider or something else. Why? Because of this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">func</span> <span class="o">-&gt;&gt;</span> <span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">U</span><span class="p">:</span> <span class="kt">Bondable</span> <span class="k">where</span> <span class="kt">U</span><span class="o">.</span><span class="kt">BondType</span> <span class="o">==</span> <span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">left</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">U</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">left</span> <span class="o">-&gt;&gt;</span> <span class="k">right</span><span class="o">.</span><span class="n">designatedBond</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It overloads the -» operator so it can bind a Dynamic to an object that adheres to Bondable protocol (given that generic types match - you cannot bind an image to a label).</p>

<p>With that, our binding is reduced to something as simple as:
<code class="highlighter-rouge">swift
name -&gt;&gt; nameLabel
</code></p>

<p>Awesome.</p>

<h2>Handling mismatching types</h2>

<p>Let’s consider <em>likeCount</em> property. It’s a number, so we’ll redefine it as follows:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">likeCount</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
</code></pre>
</div>

<p>How do we bind it to a label? If you’re thinking about</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">likeCount</span> <span class="o">-&gt;&gt;</span> <span class="n">likeCountLabel</span>
</code></pre>
</div>

<p>you’re mistaken. Problem is that <em>likeCount</em> holds an Int value, but label expects a String value. That line would not even compile, which is a good thing as it means that our solution is type-safe. We need to somehow add support for type transformations. In functional paradigm that’s called mapping. As Swift partially leans toward the function paradigm, let’s see how a map function that operates on a Dynamics would look like.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">func</span> <span class="n">map</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">,</span> <span class="kt">U</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">dynamic</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">f</span><span class="p">:</span> <span class="kt">T</span> <span class="o">-&gt;</span> <span class="kt">U</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">U</span><span class="o">&gt;</span>
</code></pre>
</div>

<p>For the sake of length of this post, let’s ignore implementation details. You can look it up on GitHub should you be interested. You will find the link at the bottom.</p>

<p>What map does is converts Dynamic of some type T to a Dynamic of some type U. It does that by applying given closure that converts value from type T to type U. With that, we can solve out like count problem.</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="nf">map</span><span class="p">(</span><span class="n">likeCount</span><span class="p">)</span> <span class="p">{</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span> <span class="o">-&gt;&gt;</span> <span class="n">likeCountLabel</span>
</code></pre>
</div>

<p>It’s also possible extend Dynamic class with map function and do binding like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="n">likeCount</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span> <span class="o">-&gt;&gt;</span> <span class="n">likeCountLabel</span>
</code></pre>
</div>

<p>With all that, we can now rewrite our initial example with new approach. We need to convert static properties of the model to dynamic ones</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Thread</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
  <span class="k">let</span> <span class="nv">posts</span><span class="p">:</span> <span class="p">[</span><span class="kt">Post</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Post</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
  <span class="k">let</span> <span class="nv">likeCount</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>and update the view controller to do binding instead of assignment</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ThreadViewController</span><span class="p">:</span> <span class="kt">UIViewController</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">thread</span><span class="p">:</span> <span class="kt">Thread</span>
  <span class="k">var</span> <span class="nv">threadView</span><span class="p">:</span> <span class="kt">ThreadView</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">text</span> <span class="o">-&gt;&gt;</span> <span class="n">threadView</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span>
    <span class="n">threadView</span><span class="o">.</span><span class="n">postsTableView</span><span class="o">.</span><span class="n">dataSource</span> <span class="o">=</span> <span class="k">self</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">numberOfRowsInSection</span> <span class="nv">section</span><span class="p">:</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">thread</span><span class="o">.</span><span class="nf">count</span><span class="p">()</span>
  <span class="p">}</span>

  <span class="kd">func</span> <span class="nf">tableView</span><span class="p">(</span><span class="nv">tableView</span><span class="p">:</span> <span class="kt">UITableView</span><span class="p">,</span> <span class="n">cellForRowAtIndexPath</span> <span class="nv">indexPath</span><span class="p">:</span> <span class="kt">NSIndexPath</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">UITableViewCell</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="s">"PostCell"</span><span class="p">)</span> <span class="k">as</span> <span class="kt">PostCell</span>
    <span class="k">let</span> <span class="nv">post</span> <span class="o">=</span> <span class="n">thread</span><span class="o">.</span><span class="n">posts</span><span class="p">[</span><span class="n">indexPath</span><span class="o">.</span><span class="n">row</span><span class="p">]</span>

    <span class="n">post</span><span class="o">.</span><span class="n">body</span> <span class="o">-&gt;&gt;</span> <span class="n">cell</span><span class="o">.</span><span class="n">bodyTextView</span><span class="o">.</span><span class="n">text</span>
    <span class="n">post</span><span class="o">.</span><span class="n">likeCount</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span> <span class="o">-&gt;&gt;</span> <span class="n">cell</span><span class="o">.</span><span class="n">likeCountLabel</span><span class="o">.</span><span class="n">text</span>

    <span class="k">return</span> <span class="n">cell</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Looks almost identical to initial version, but with significant difference in that the data is now bonded to user interface and any change to it will be automatically reflected in views.</p>

<p>There is one problem though - it works great for scalar types, but what about arrays? How do we update the table view when new posts arrive?</p>

<h2>Arrays are special</h2>
<p>When dealing with arrays, we are usually not interested in the change of the array object as whole, rather in changes that occurred within the array itself like insertions, deletions or updates.</p>

<p>Bond object allows us to observe only value changes, and value is in this case an array as whole. In order to observe fine-grain changes, we need a special kind of Bond. For example a Bond defined in following way:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">ArrayBond</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">Bond</span><span class="o">&lt;</span><span class="kt">Array</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">insertListener</span><span class="p">:</span> <span class="p">(([</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>
  <span class="k">var</span> <span class="nv">removeListener</span><span class="p">:</span> <span class="p">(([</span><span class="kt">Int</span><span class="p">],</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>
  <span class="k">var</span> <span class="nv">updateListener</span><span class="p">:</span> <span class="p">(([</span><span class="kt">Int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kt">Void</span><span class="p">)?</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It would allow us to register different listeners for different events. Each listener is a closure that accepts an array of indices of elements that have been changed in bonded Dynamic. Removal listener also receives elements that are removed.</p>

<p>Our Dynamic doesn’t know when and how to call these new listeners, so we would need a special kind of Dynamic. One with additional methods for array manipulation. We would need something that would work as following example:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="k">let</span> <span class="nv">posts</span> <span class="o">=</span> <span class="kt">DynamicArray</span><span class="o">&lt;</span><span class="kt">Post</span><span class="o">&gt;</span><span class="p">()</span>
<span class="k">let</span> <span class="nv">myBond</span> <span class="o">=</span> <span class="kt">ArrayBond</span><span class="o">&lt;</span><span class="kt">Post</span><span class="o">&gt;</span><span class="p">()</span>

<span class="n">myBond</span><span class="o">.</span><span class="n">insertListener</span> <span class="o">=</span> <span class="p">{</span> <span class="n">indices</span> <span class="k">in</span>
  <span class="nf">println</span><span class="p">(</span><span class="s">"Inserted posts at indices </span><span class="se">\(</span><span class="n">indices</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">myBond</span><span class="o">.</span><span class="n">updateListener</span> <span class="o">=</span> <span class="p">{</span> <span class="n">indices</span> <span class="k">in</span>
  <span class="nf">println</span><span class="p">(</span><span class="s">"Updated posts at indices </span><span class="se">\(</span><span class="n">indices</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">posts</span> <span class="o">-&gt;&gt;</span> <span class="n">myBond</span>

<span class="n">posts</span><span class="o">.</span><span class="nf">insert</span><span class="p">(</span><span class="kt">Post</span><span class="p">(</span><span class="o">...</span><span class="p">),</span> <span class="nv">atIndex</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">// prints: Inserted posts at indices [0]</span>

<span class="n">posts</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="kt">Post</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="c1">// prints: Updated posts at indices [4]</span>
</code></pre>
</div>

<p>What’s interesting with that is that it would allow us to extend a table view with a Bond that acts as its data source. The Bond would accept Dynamics of UITableViewCell type and we could use map function to convert posts to cells, like this:</p>

<div class="language-swift highlighter-rouge"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Thread</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
  <span class="k">let</span> <span class="nv">posts</span><span class="p">:</span> <span class="kt">DynamicArray</span><span class="o">&lt;</span><span class="kt">Post</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">Post</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">body</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span>
  <span class="k">let</span> <span class="nv">likeCount</span><span class="p">:</span> <span class="kt">Dynamic</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">ThreadViewController</span><span class="p">:</span> <span class="kt">UIViewController</span><span class="p">,</span> <span class="kt">UITableViewDataSource</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">thread</span><span class="p">:</span> <span class="kt">Thread</span>
  <span class="k">var</span> <span class="nv">threadView</span><span class="p">:</span> <span class="kt">ThreadView</span>

  <span class="k">override</span> <span class="kd">func</span> <span class="nf">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="o">.</span><span class="nf">viewDidLoad</span><span class="p">()</span>

    <span class="n">thread</span><span class="o">.</span><span class="n">text</span> <span class="o">-&gt;&gt;</span> <span class="n">threadView</span><span class="o">.</span><span class="n">nameLabel</span><span class="o">.</span><span class="n">text</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">posts</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">[</span><span class="k">unowned</span> <span class="k">self</span><span class="p">]</span> <span class="p">(</span><span class="nv">post</span><span class="p">:</span> <span class="kt">Post</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">PostCell</span> <span class="k">in</span>
      <span class="k">let</span> <span class="nv">cell</span> <span class="o">=</span> <span class="k">self</span><span class="o">.</span><span class="n">tableView</span><span class="o">.</span><span class="nf">dequeueReusableCellWithIdentifier</span><span class="p">(</span><span class="s">"PostCell"</span><span class="p">)</span> <span class="k">as</span> <span class="kt">PostCell</span>

      <span class="n">post</span><span class="o">.</span><span class="n">body</span> <span class="o">-&gt;&gt;</span> <span class="n">cell</span><span class="o">.</span><span class="n">bodyTextView</span><span class="o">.</span><span class="n">text</span>
      <span class="n">post</span><span class="o">.</span><span class="n">likeCount</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">"</span><span class="se">\(</span><span class="nv">$0</span><span class="se">)</span><span class="s">"</span> <span class="p">}</span> <span class="o">-&gt;&gt;</span> <span class="n">cell</span><span class="o">.</span><span class="n">likeCountLabel</span><span class="o">.</span><span class="n">text</span>
      
      <span class="k">return</span> <span class="n">cell</span>
    <span class="p">}</span> <span class="o">-&gt;&gt;</span> <span class="k">self</span><span class="o">.</span><span class="n">tableView</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>It would allow us to populate and bind whole screen with few simple binding operators. Going through the implementation details of how it could be achieved is beyond this post, but concepts are very similar to ones presented for scalar values.</p>

<h2>Conclusion</h2>
<p>Presented solution boils binding problem down to just one operator. It’s simple, powerful, type-safe and multi-paradigm - just like Swift. It allows you to think differently when coupling data with the view and makes the whole process smooth.</p>

<p>You can find implementation of presented concepts on GitHub in a framework named Bond. It includes both implementation of scalar Dynamic and Bond classes, as well as implementation of vector DynamicArray and ArrayBond classes. You can find it at <a href="https://github.com/SwiftBond/Bond">https://github.com/SwiftBond/Bond</a>.</p>

</div>

<!-- Share links section -->
<!-- Go to www.addthis.com/dashboard to customize your tools -->
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5741886ff6c25748"></script>


<!-- Disqus comments -->

    <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">

        var disqus_shortname = 'rasicinfo'; 
        var disqus_developer = 0; // developer mode is on
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/a-different-take-on-mvvm-with-swift/">
            A Different Take on MVVM with Swift
            <small>31 May 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/implementing-reactive-delegates-in-swift-powered-by-objective-c/">
            Implementing Reactive Delegates in Swift Powered by Objective-C
            <small>28 May 2016</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/bindings-generics-swift-and-mvvm/">
            Bindings, Generics, Swift and MVVM
            <small>10 Dec 2014</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>

    <!-- Google Analytics Tracking code -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-48112103-2', 'auto');
      ga('send', 'pageview');

    </script>
  </body>
</html>
